JVM(Java Virtual Machine) is a Java application run-time engine.
=> JVM is the one that calls the main method present in Java code
=> JVM is a part of the JRE(Java Run-time Environment)
=> Java applications are called WORA(Write Once Run Anywhere)
    + Because of JVM, you can write Java code on one system and expect it to run on any
    Java-enabled system without any adjustment
=> When we compile a .java file, a file with the same name but with .class extension which
contains byte-code is generated by the Java compiler. This file  goes into various steps
with the JVM:
    Class loader Subsystem:
        1. Loading: The class loader reads the .class file. It then generates the corresponding
        binary data and saves it in "method area". For each .class file JVM stores the below
        information:
            + fully qualified name of the loaded class and its immediate parent
            + whether the class is related to Class, interface or Enum
            + Modifier, Variables and Method information
         -> After loading, JVM creates an object of type Class to represent this file in the heap memory
        2. Linking: Performs verification, preparation and resolution(optional)
            + Verification: Ensures the correctness of the .class file by checking if the file
            is properly formatted and generated by the valid compiler. If fails, we get runtime
            exception java.lang.VerifyError
            + Preparation: JVM allocates memory for class variables and initializing the memory to default values.
            + Resolution:  It is the process of replacing symbolic references from the type with direct references.
            It is done by searching into method area to locate the referenced entity.
        3. Initialization: In this phase, all static variables are assigned with their values defined in the code and static block(if any).
        This is executed from top to bottom in a class and from parent to child in class hierarchy.
        In general, there are three class loaders:
            + bootstrap class loader : Every JVM implementation must have a bootstrap class loader, capable of loading trusted classes.
            It loads core java API classes present in JAVA_HOME/jre/lib directory. This path is
            popularly known as bootstrap path. It is implemented in native languages like C, C++.
            + Extension class loader : It is child of bootstrap class loader. It loads
            the classes present in the extensions directories JAVA_HOME/jre/lib/ext
            (Extension path) or any other directory specified by the java.ext.dirs
            system property. It is implemented in java by the sun.misc.Launcher$ExtClassLoader class.
            + System/Application class loader : It is child of extension class loader.
            It is responsible to load classes from application class path. It internally
            uses Environment Variable which mapped to java.class.path. It is also
            implemented in Java by the sun.misc.Launcher$AppClassLoader class.

    JVM memory:
        + Method area: stores class-level information like class name, immediate parent,
         methods and variables.
            - There can only be one Method area per JVM, and it is a shared resource
        + Heap area: stores the information of all objects
            - There is only one Heap area, and it is also a shared resource
        + Stack area: Stores runtime stacks created by JVM for every thread.
            - Every block of stack is called stack frame which stores method calls
            - All local variables of that method is stored inside the corresponding frame
            - The runtime stack will be destroyed by JVM when the corresponding thread
            is terminated
            - It is not a shared resource
        + PC Registers: Stores address of the current execution instruction of a thread.
            - each thread has separate PC Registers.
        + Native method stacks: Stores native methods information
            - A native method stack is created for every thread
    Execution engine:
        + Interpreter: Interprets the bytecode line by line then execute
            - The disadvantage is that if the method is called multiple time, interpretation
            is required every time
        + Just-In-Time compiler(JIT): Compiles the entire bytecode and changes it into
          native code.
            - Whenever it sees repeated method calls, it will provide direct native code for
            that part, thus removes reinterpretation and increases efficiency of the interpreter
        + Garbage collector: destroys unreferenced objects
    Java Native Interface: Interacts with native method libraries and provide the required native
    methods libraries for execution
        + It enables JVM to call and be called by C/C++ libraries
    Native method libraries: A collection of Native libraries(C,C++) which are required for execution



